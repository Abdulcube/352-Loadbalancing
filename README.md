# 352-Loadbalancing
Explore a design that implements load balancing among DNS servers by splitting the set of hostnames across multiple DNS servers.
Abdulrahman Abdulrahman (aa1684) and Manav Patel (mjp430)

### 1. Briefly discuss how you implemented the LS functionality of tracking which TS responded to the query and timing out if neither TS responded.
  When creating the socket for the respective top-level servers, the socket is initialized to a non-blocking type, allowing the program to continue to run regardless of the result of the ts domain status. With the loading balancing server making a call to the ts program, the select.select() python system call is used to notify when the descriptors in the function are ready to be used. The call is made with a timeout set for the allocation of 5 seconds, where if the top-level server does not become ready to send data, the load balancing server moves on from that sockets call. If the socket passed in has data to be received, the select function will be returning the sockets that are sending data, and the ls sends the received data to the client. If the program does not receive data from either of the ts severs, the ls sends to the client 'NS' (line 81). By querying a top-level server, returning after the allotted timeout period, and forwarding to the next server, there will only be a single response that will be sent to the client. The ls checks for a response before moving on to next select.select call. 

### 2. Are there known issues or functions that aren't working currently in your attached code? If so, explain.
  Based on provided test cases and edge cases tested by the students, all aspects of the programs are fully functional with correct input and output format. The code has been tested on Rutgers iLab machines, ensuring the correct python version and allowing a test of cross device connections through the sockets.

### 3. What problems did you face developing code for this project?
  One of the issues that was faced while working on the project was debugging with multiple different processes running simultaneously. While working with two top-level domains, a root server, and a client, a single test run would require four terminal windows to be running in parallel, causing difficulties with running order. For example, severs running before client access, etc. Another issue faced with the python syntax was an extension of the first project and data types with socket programming. While sending strings and domain addresses across servers, the encoding and decoding of the data between unicode and strings were constantly being manipulated to isolate the responses based on different scenarios. One of the challenges with differing datatypes is ensuring correct arguments to python based functions. To mitigate any confusion, comments and sprint programming practices were utilized to allow focused manipulation of variables.
### 4. What did you learn by working on this project?
  While a couple of the core ideals from the project were a repeat from the first assignment, this project helped solidify our usage of python in network programming. The usage of file API's and creations of sockets were practiced and repetition of server debugging has been fruitful in our understanding of DNS servers and implementations of mapping hostnames. With the new usage of non-blocking sockets, we also learned more python functionality for network level programming.
